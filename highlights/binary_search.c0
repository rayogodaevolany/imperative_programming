// This was one of the first program proofs that actually made sense to me.
// I actually understood what the contract was semantically indicating.

// search an s sorted array, A(n) for x
int binary_search(int x, int[] A, int n)
//@requires n == \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x,A,0,n))
        || ((0 <= \result && \result < n) && A[\result] == x);
@*/
{
    int lo = 0;
    int hi = n - 1;
    while (lo <= hi)
        //@loop_invariant 0 <= lo && lo <= hi + 1 && hi + 1 <= n;
        //@loop_invariant gt_seg(x,A,0,lo);
        //@loop_invariant lt_seg(x,A,hi+1,n);
    {
        int mid = lo + (hi - lo) /2;
        //@assert lo <= mid && mid <= hi;
        
        if (A[mid] == x) return mid;
        if (A[mid] > x) {
            hi = mid - 1;
        } else {
            //@assert A[mid] < x;
            lo = mid + 1;
        }
    }

    //@assert lo == hi + 1;
    return -1;
}

// INIT
//  LI 1
//   a. lo = 0 by line
//   b. 0 <= lo by math on a
//   c. hi + 1 = (n - 1) + 1 by line and math
//   d. hi = n by c
//   e. 0 <= n by precondition (\length(A))
//   f. lo <= n && n <= n by a, e, and math
//   g. 0 <= lo && lo <= hi + 1 && hi + 1 <= n

//  LI 2
//   a. lo = 0 by line
//   b. gt_seg(x,A,0,0) by math (x is greater than empty segment)
//   c. gt_seg(x,A,0,lo) by b

//  LI 3
//   a. hi = n - 1 by line
//   b. lt_seg(x,A,n,n) by math ( x is less than empty segment)
//   c. lt_sef(x,A,hi+1,n) by b

//  PRES
//   A[mid] == x
//    trivially case
      
//   A[mid] > x
//    a. hi = mid - 1
//     LI 1 
//      a. hi + 1 = (mid - 1) + 1 by line (hi = mid - 1) 
//      b. hi' = mid by a
//      c. lo <= mid && mid <= hi by assertion
//      d. 0 <= lo && lo <= hi' by assumption and b,c
//      e. lo <= hi' + 1 by math on d
//      f. hi' <= hi by assertion
//      g. hi' + 1 <= hi + 1 by math on f
//      h. hi' + 1 <= n by math on assumption
//     LI 2
//      i. gt_seg(x,A,0,lo) by assumption and lo doesn't change
//     LI 3
//      j. hi + 1 = mid by math on a
//      k. x < A[mid] by line
//      l. lt_seg(x,A,mid,n) by k, precondition(sorted), and j
//      m. lt_seg(x,A,hi' + 1, n) by l
      
//   A[mid] < x
//    a. lo' = mid + 1 by line
//     LI 1 
//      b. lo <= mid + 1 && mid + 1 <= hi + 1 by math on assertion
//      c. 0 <= 'lo && 'lo <= hi + 1 && hi + 1 <= n by math on assumption and a,b
//      d. 0 <= 'lo && 'lo <= 'hi + 1 && 'hi + 1 <= n by assumption (hi is preserved)
//     LI 2
//      e. x > A[mid] by assertion
//      f. gt_seg(x,A,0,mid+1) by math on precondition(sorted) and e
//      g. gt_seg(x,A,0,'lo) by a, e, and f
//     LI 3
//      h. hi is preserved, trivially true
//  ASSERTION
//   A1
//    a. 0 <= (hi-lo)/2 by math on loop guard
//    b. lo <= lo + (hi-lo)/2 by math on a
//    c. (hi - lo)/2 <= (hi - lo) by math
//    d. lo + (hi - lo)/2 <= hi by math on c
//    e. 0 <= lo + (hi-lo)/2 <= hi
//    f. 0 <= mid <= hi
//   A2
//    a. A[mid] != x by line
//    b. A[mid] <= x by line
//    c. A[mid] < x by a and c
//   A3
//    a. lo > hi by loop guard failing
//    b. lo <= hi + 1 by loop invariant
//    c. lo == hi + 1 by a and b
//  TERM
//      On an arbitrary iteration of the loop, hi - lo is strictly decreasing (hi is decreasing or lo is increasing), and cannot be less than -1. The guard is false when hi - lo is -1
//  EXIT
//     if \result is -1:
//      a. lo == hi + 1 by assertion
//      b. gt_seg(x,A,0,hi + 1) && lt_seg(x,A,hi+1,n) by loop invariants and a
//      c. !is_in(x,A,0,n) by math on b
//     else
//      a. \result == mid && A[mid] == x by line
//      b. lo <= mid && mid <= hi by assertion
//      c. hi <= hi + 1 && hi < n by math on loop invariant
//      d. 0 <= lo <= mid <= hi < n by math on loop invariant and b, c
//      e. 0 <= \result && \result < n by d
//      f. A[\result] == x by a 

int testbinary_search(){
    int n = 3;
    int[] A = alloc_array(int, n);
    A[0] = 1; 
    A[1] = 5;
    A[2] = 8;

    int front = binary_search(1,A,n);
    int middle = binary_search(5,A,n);
    int end = binary_search(8,A,n);
    assert(front == 0);
    assert(middle == 1);
    assert(end == 2);

    return 0;
}
