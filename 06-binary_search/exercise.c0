//Lecture notes ==========================================================


// search an s sorted array, A(n) for x
int binsearch(int x, int[] A, int n)
//@requires 0 <= n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x,A,0,n))
        || ((0 <= \result && \result < n) && A[\result] == x);
@*/
{
    int lo = 0;
    int hi = n;
    while (lo < hi)
        //@loop_invariant 0 <= lo && lo <= hi && hi <= n;
        //@loop_invariant (lo == 0 || A[lo -1] < x);
        //@loop_invariant (hi == n || A[hi] > x);
    {
        int mid = lo + (hi - lo) /2;
        //@assert lo <= mid && mid < hi;
        
        if (A[mid] == x) return mid;
        if (A[mid] > x) {
            hi = mid;
        } else {
            //@assert A[mid] < x;
            lo = mid + 1;
        }
    }

    //@assert lo == hi;
    return -1;
}

int testbinsearch(){
    int n = 3;
    int[] A = alloc_array(int, n);
    A[0] = 1; 
    A[1] = 5;
    A[2] = 8;

    int res = binsearch(5,A,n);
    assert(res == 1);

    return 0;
}


//Exercise 1 ==========================================================

// Refactor binsearch so that internally, it uses inclusive bound for both upper and lower bounds

// search an s sorted array, A(n) for x
int binsearch(int x, int[] A, int n)
//@requires 0 < n && n <= \length(A);
//@requires is_sorted(A, 0, n);
/*@ensures (-1 == \result && !is_in(x,A,0,n))
        || ((0 <= \result && \result < n) && A[\result] == x);
@*/
{
    int lo = 0;
    int hi = n - 1;
    while (lo < hi)
        //@loop_invariant 0 <= lo && lo <= hi && hi < n;
        //@loop_invariant (lo == 0 || A[lo - 1] < x);
        //@loop_invariant (hi == n - 1 || A[hi] > x);
    {
        int mid = lo + (hi - lo) /2;
        //@assert lo <= mid && mid < hi;
        
        if (A[mid] == x) return mid;
        if (A[mid] > x) {
            hi = mid;
        } else {
            //@assert A[mid] < x;
            lo = mid + 1;
        }
    }

    //@assert lo == hi;
    return -1;
}

// 1. Show loop invariants hold initially

//  loop invariant 1:
//   a. lo = 0 by line
//   b. 0 <= n - 1 by math on precondition
//   c. lo <= hi by math on a, b, and line where hi is defined
//   d. n - 1 < n by math on line
//   e. 0 <= lo && lo <= hi && hi < n initially

//  loop invariant 2:
//   a. lo == 0;

//  loop invariant 3:
//   a. hi == n - 1;

// 2. Show loop invariants are preserved:

//  case 1 A[mid] == x:
//   trivially correct

//  case 2 A[mid] > x:
//   a. hi' == mid && lo == 'lo by line
//   loop invariant 1:
//    b. lo <= mid by assertion
//    c. 0 <= lo' && lo' <= mid && mid < n by math on b and assertions
//    d. 0 <= lo' && lo' <= hi' && hi' < n by math on b and assertions.
//   loop invariant 2:
//    e. lo doesn't change so preserved
//   loop invariant 3: 
//    f. A[mid] > x by 

//  case 3 A[mid] < x:
//   e. 
